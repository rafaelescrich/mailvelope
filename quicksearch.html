<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"client-api.js.html":{"id":"client-api.js.html","title":"Source: client-api.js","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Source: client-api.js /** * The MIT License (MIT) * * Copyright (c) 2014-2019 Mailvelope GmbH * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ /** * @type {Mailvelope} */ class Mailvelope { /** * Gives access to the mailvelope extension version * @returns {Promise.&lt;String, Error&gt;} */ getVersion() { return send('get-version'); } /** * Retrieves the Keyring for the given identifier * @param {string} identifier - the identifier of the keyring * @returns {Promise.&lt;Keyring, Error&gt;} * @throws {Error} error.code = 'NO_KEYRING_FOR_ID' */ getKeyring(identifier) { return send('get-keyring', {identifier}).then(options =&gt; new Keyring(identifier, options)); } /** * Creates a Keyring for the given identifier * @param {string} identifier - the identifier of the new keyring * @returns {Promise.&lt;Keyring, Error&gt;} * @throws {Error} error.code = 'KEYRING_ALREADY_EXISTS' * @example * mailvelope.createKeyring('Account-ID-4711').then(function(keyring) { * // continue to display the settings container and start the setup wizard * mailvelope.createSettingsContainer('#mailvelope-settings', keyring); * }); */ createKeyring(identifier) { return send('create-keyring', {identifier}).then(options =&gt; new Keyring(identifier, options)); } /** * Ascii Armored PGP Text Block * @typedef {string} AsciiArmored */ /** * CSS Selector String * @typedef {string} CssSelector */ /** * @typedef {Object} DisplayContainerOptions * @property {boolean} showExternalContent - if true loads external content into the display container (default: true) * @property {string} senderAddress - email address of sender, used to indentify key for signature verification */ /** * @typedef {Object} DisplayContainer * @property {Error} error - Error object with code and message attribute * error.code = 'DECRYPT_ERROR' - generic decrypt error * error.code = 'ARMOR_PARSE_ERROR' - error while parsing the armored message * error.code = 'PWD_DIALOG_CANCEL' - user canceled password dialog * error.code = 'NO_KEY_FOUND' - no private key found to decrypt this message */ /** * Creates an iframe to display the decrypted content of the encrypted mail. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {AsciiArmored} armored - the encrypted mail to display * @param {Keyring} keyring - the keyring to use for this operation * @param {DisplayContainerOptions} options * @returns {Promise.&lt;DisplayContainer, Error&gt;} */ createDisplayContainer(selector, armored, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return send('display-container', {selector, armored, identifier: keyring.identifier, options}).then(display =&gt; { if (display &amp;&amp; display.error) { display.error = mapError(display.error); } return display; }); } /** * @typedef {Object} EditorContainerOptions * @property {number} quota - mail content (text + attachments) limit in kilobytes (default: 20480) * @property {boolean} signMsg - if true then the mail will be signed (default: false) * @property {AsciiArmored} armoredDraft - a PGP message, signed and encrypted with the default key of the user, will be used to restore a draft in the editor * The armoredDraft parameter can't be combined with the parameters: predefinedText, quotedMail... parameters, keepAttachments * @property {string} predefinedText - text that will be added to the editor * @property {AsciiArmored} quotedMail - mail that should be quoted * @property {boolean} quotedMailIndent - if true the quoted mail will be indented (default: true) * @property {string} quotedMailHeader - header to be added before the quoted mail * @property {boolean} keepAttachments - add attachments of quotedMail to editor (default: false) */ /** * Creates an iframe with an editor for a new encrypted mail. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {Keyring} keyring - the keyring to use for this operation * @param {EditorContainerOptions} options * @returns {Promise.&lt;Editor, Error&gt;} * @throws {Error} error.code = 'WRONG_ARMORED_TYPE' - parameters of type AsciiArmored do not have the correct armor type &lt;br&gt; error.code = 'INVALID_OPTIONS' - invalid combination of options parameter * @example * mailvelope.createEditorContainer('#editor-element', keyring).then(function(editor) { * // register event handler for mail client send button * $('#mailer-send').click(function() { * // encrypt current content of editor for array of recipients * editor.encrypt(['info@mailvelope.com', 'abc@web.de']).then(function(armored) { * console.log('encrypted message', armored); * }); * }); * }); */ createEditorContainer(selector, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return send('editor-container', {selector, identifier: keyring.identifier, options}).then(editorId =&gt; new Editor(editorId)); } /** * @typedef {Object} SettingsContainerOptions * @property {string} email - the email address of the current user * @property {string} fullName - the full name of the current user */ /** * Creates an iframe to display the keyring settings. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {Keyring} keyring - the keyring to use for the setup * @param {SettingsContainerOptions} options * @returns {Promise.&lt;undefined, Error&gt;} */ createSettingsContainer(selector, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return send('settings-container', {selector, identifier: keyring.identifier, options}); } /** * Creates an iframe to display an encrypted form * The iframe will be injected into the container identified by selector. * @param @param {string} selector - the id of target container * @param @param {string} formHtml - the form definition * @param @param {string} signature - the OpenPGP signature * @returns {Promise.&lt;Object, Error&gt;} an object that includes armoredData * @throws {Error} error.code = 'INVALID_FORM' the form definition is not valid */ createEncryptedFormContainer(selector, formHtml, signature) { return send('encrypted-form-container', {selector, formHtml, signature}); } } // connection to content script is alive let connected = true; let syncHandler = null; function checkTypeKeyring(keyring) { if (!(keyring instanceof Keyring)) { const error = new Error('Type mismatch: keyring should be instance of Keyring.'); error.code = 'TYPE_MISMATCH'; throw error; } } /** * Not accessible, instance can be obtained using {@link Mailvelope#getKeyring} * or {@link Mailvelope#createKeyring}. * @param {string} identifier - the keyring identifier * @param {object} options - the options * @property {number} logoRev - revision number of the keyring logo, initial value: 0 */ class Keyring { constructor(identifier, options) { this.identifier = identifier; this.logoRev = options.revision || 0; } /** * Checks for valid key in the keyring for provided email addresses * @param {Array} recipients - list of email addresses for key lookup * @return {Promise.&lt;Object, Error&gt;} an object that maps email addresses to a status or key info object (false: no valid key, {}: valid key) * @example * keyring.validKeyForAddress(['abc@web.de', 'info@mailvelope.com']).then(function(result) { * console.log(result); * // { * // 'abc@web.de': false, * // 'info@mailvelope.com': { * // keys: [ * // {fingerprint: 'f37377c39898d05ffd39157a98bbec557ce08def', lastModified: Tue May 19 2015 10:36:53 GMT+0200 (CEST)} * // ] * // } * }); */ validKeyForAddress(recipients) { return send('query-valid-key', {identifier: this.identifier, recipients}).then(keyMap =&gt; { for (const address in keyMap) { if (keyMap[address]) { keyMap[address].keys.forEach(key =&gt; { key.lastModified = new Date(key.lastModified); }); } } return keyMap; }); } /** * Exports the public key as an ascii armored string. * Only keys belonging to the user (corresponding private key exists) can be exported. * @param {string} emailAddr - email address to identify the public+private key * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'NO_KEY_FOR_ADDRESS' * @example * keyring.exportOwnPublicKey('abc@web.de').then(function(armoredPublicKey) { * console.log('exportOwnPublicKey', armoredPublicKey); // prints: \"-----BEGIN PGP PUBLIC KEY BLOCK...\" * }); */ exportOwnPublicKey(emailAddr) { return send('export-own-pub-key', {identifier: this.identifier, emailAddr}); } /** * Asks the user if they want to import the public key. * @param {AsciiArmored} armored - public key to import * @returns {Promise.&lt;String, Error&gt;} 'IMPORTED' - key has been imported &lt;br&gt; 'UPDATED' - key already in keyring, new key merged with existing key &lt;br&gt; 'INVALIDATED' - key has been updated, new status of key is 'invalid' (e.g. revoked) &lt;br&gt; 'REJECTED' - key import rejected by user * @throws {Error} error.code = 'IMPORT_ERROR' &lt;br&gt; error.code = 'WRONG_ARMORED_TYPE' */ importPublicKey(armored) { return send('import-pub-key', {identifier: this.identifier, armored}); } /** * Set logo for keyring. The image is persisted in Mailvelope with a revision number, * therefore the method is only required after new keyring generation or if logo and revision number changes. * @param {string} dataURL - data-URL representing the logo, max. file size: ~10KB, max. image size: 192x96px, content-type: image/png * @param {number} revision - revision number * @returns {Promise.&lt;undefined, Error&gt;} * @throws {Error} error.code = 'LOGO_INVALID' &lt;br&gt; * error.code = 'REVISION_INVALID' * @example * keyring.setLogo('data:image/png;base64,iVBORS==', 3).then(function() { * // keyring.logoRev == 3 * }).catch(function(error) { * // logo update failed * }); * */ setLogo(dataURL, revision) { return send('set-logo', {identifier: this.identifier, dataURL, revision}).then(() =&gt; { this.logoRev = revision; }); } /** * @typedef {Object} UserId * @property {string} email - the email address of the current user * @property {string} fullName - the full name of the current user */ /** * @typedef {Object} KeyGenContainerOptions * @property {Array.&lt;UserId&gt;} userIds - array of user IDs. The first entry in the array is set as the primary user ID. * @property {number} keySize - key size in bit, optional, default: 2048, valid values: 2048, 4096. */ /** * Creates an iframe to display the key generation container. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {KeyGenContainerOptions} options * @returns {Promise.&lt;Generator, Error&gt;} * @throws {Error} error.code = 'INPUT_NOT_VALID' */ createKeyGenContainer(selector, options) { return send('key-gen-container', {selector, identifier: this.identifier, options}).then(generatorId =&gt; new Generator(generatorId)); } /** * @typedef {Object} KeyBackupContainerOptions * @param {Boolean} initialSetup (default: true) */ /** * Creates an iframe to initiate the key backup process. * @param {CssSelector} selector - target container * @param {KeyBackupContainerOptions} options * @returns {Promise.&lt;KeyBackupPopup, Error&gt;} */ createKeyBackupContainer(selector, options) { return send('key-backup-container', {selector, identifier: this.identifier, options}).then(popupId =&gt; new KeyBackupPopup(popupId)); } /** * @typedef {Object} PrivateKeyContainerOptions * @property {boolean} restorePassword (default: false) */ /** * Creates an iframe to restore the backup. * @param {CssSelector} selector - target container * @param {PrivateKeyContainerOptions} options * @returns {Promise.&lt;undefined, Error&gt;} */ restoreBackupContainer(selector, options) { return send('restore-backup-container', {selector, identifier: this.identifier, options}).then(restoreId =&gt; new RestoreBackup(restoreId)); } /** * Check if keyring contains valid private key with given fingerprint * @param {string} fingerprint * @returns {Promise.&lt;boolean, Error&gt;} */ hasPrivateKey(fingerprint) { return send('has-private-key', {identifier: this.identifier, fingerprint}).then(result =&gt; result); } /** * @typedef {Object} UploadSyncReply * @property {String} eTag - entity tag for the uploaded encrypted keyring */ /** * @typedef {Function} UploadSyncHandler * @param {Object} uploadObj - object with upload data * @param {string} uploadObj.eTag - entity tag for the uploaded encrypted keyring, or null if initial upload * @param {AsciiArmored} uploadObj.keyringMsg - encrypted keyring as PGP armored message * @returns {Promise.&lt;UploadSyncReply, Error&gt;} - if version on server has different eTag, then the promise is rejected * if server is initial and uploadObj.eTag is not null, then the promise is rejected */ /** * @typedef {Object} DownloadSyncReply * @property {AsciiArmored} keyringMsg - encrypted keyring as PGP armored message, or null if no newer version available * @property {String} eTag - entity tag for the current encrypted keyring message, or null if server is intial */ /** * @typedef {Function} DownloadSyncHandler * @param {Object} downloadObj - meta info for download * @param {string} downloadObj.eTag - entity tag for the current local keyring, or null if no local eTag * @returns {Promise.&lt;DownloadSyncReply, Error&gt;} - if version on server has same eTag, then keyringMsg property of reply is empty, but eTag in reply has to be set * if server is initial and downloadObj.eTag is not null, then the promise is resolved with empty eTag */ /** * @typedef {Object} BackupSyncPacket * @property {AsciiArmored} backup - encrypted key backup as PGP armored message */ /** * @typedef {Function} BackupSyncHandler * @param {BackupSyncPacket} - object with backup data * @returns {Promise.&lt;undefined, Error&gt;} */ /** * @typedef {Function} RestoreSyncHandler * @returns {Promise.&lt;BackupSyncPacket, Error&gt;} */ /** * @typedef {Object} SyncHandlerObject * @property {UploadSyncHandler} uploadSync - function called by Mailvelope to upload the keyring (public keys), the message is encrypted with the default private key * @property {DownloadSyncHandler} downloadSync - function called by Mailvelope to download the encrypted keyring (public keys) * @property {BackupSyncHandler} backup - function called by Mailvelope to upload a symmetrically encrypted private key backup * @property {RestoreSyncHandler} restore - function called by Mailvelope to restore a private key backup */ /** * Add various functions for keyring synchronization * @param {SyncHandlerObject} syncHandlerObj * @returns {Promise.&lt;undefined, Error&gt;} */ addSyncHandler(syncHandlerObj) { if (typeof syncHandlerObj.uploadSync !== typeof syncHandlerObj.downloadSync) { return Promise.reject(new Error('uploadSync and downloadSync Handler cannot be set exclusively.')); } return send('add-sync-handler', {identifier: this.identifier}).then(syncHandlerId =&gt; { if (syncHandler) { syncHandler.update(syncHandlerObj); } else { syncHandler = new SyncHandler(syncHandlerId, syncHandlerObj); } }); } /** * Open the extension settings in a new browser tab * @returns {Promise.&lt;undefined, Error&gt;} */ openSettings() { return send('open-settings', {identifier: this.identifier}); } } /** * Not accessible, instance can be obtained using {@link Keyring#createKeyBackupContainer} * @param {string} popupId */ class KeyBackupPopup { constructor(popupId) { this.popupId = popupId; } /** * @returns {Promise.&lt;undefined, Error&gt;} - key backup ready or error * @throws {Error} */ isReady() { return send('keybackup-popup-isready', {popupId: this.popupId}); } } /** * Not accessible, instance can be obtained using {@link Keyring#createKeyGenContainer}. * @param {string} generatorId - the internal id of the generator */ class Generator { constructor(generatorId) { this.generatorId = generatorId; } /** * Generate a private key * @param {Promise.&lt;undefined, Error&gt;} [confirm] - newly generate key is only persisted if Promise resolves, * in the reject or timeout case the generated key is rejected * @returns {Promise.&lt;AsciiArmored, Error&gt;} - the newly generated key (public part) * @throws {Error} */ generate(confirm) { return send('generator-generate', {generatorId: this.generatorId, confirmRequired: Boolean(confirm)}).then(armored =&gt; { if (confirm) { confirm.then(() =&gt; { emit('generator-generate-confirm', {generatorId: this.generatorId}); }).catch(e =&gt; { emit('generator-generate-reject', {generatorId: this.generatorId, error: e}); }); } return armored; }); } } /** * Not accessible, instance can be obtained using {@link Keyring#restoreBackupContainer}. * @param {string} restoreId - the internal id of the restore backup */ class RestoreBackup { constructor(restoreId) { this.restoreId = restoreId; } /** * @returns {Promise.&lt;undefined, Error&gt;} - key restore ready or error * @throws {Error} */ isReady() { return send('restore-backup-isready', {restoreId: this.restoreId}); } } /** * Not accessible, instance can be obtained using {@link Mailvelope#createEditorContainer}. * @param {string} editorId - the internal id of the editor */ class Editor { constructor(editorId) { this.editorId = editorId; } /** * Requests the encryption of the editor content for the given recipients. * @param {Array.&lt;string&gt;} recipients - list of email addresses for public key lookup and encryption * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'ENCRYPT_IN_PROGRESS' &lt;br&gt; * error.code = 'NO_KEY_FOR_RECIPIENT' &lt;br&gt; * error.code = 'ENCRYPT_QUOTA_SIZE' * @example * editor.encrypt(['abc@web.de', 'info@com']).then(function (armoredMessage) { * console.log('encrypt', armoredMessage); // prints: \"-----BEGIN PGP MESSAGE...\" * } */ encrypt(recipients) { return send('editor-encrypt', {recipients, editorId: this.editorId}); } /** * Encrypt and sign the content of the editor with the default key of the user. * To be used to save drafts. To restore drafts use the options.armoredDraft parameter of the createEditorContainer method. * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'ENCRYPT_IN_PROGRESS' &lt;br&gt; * error.code = 'NO_KEY_FOR_ENCRYPTION' &lt;br&gt; * error.code = 'ENCRYPT_QUOTA_SIZE' */ createDraft() { return send('editor-create-draft', {editorId: this.editorId}); } } const callbacks = Object.create(null); class SyncHandler { constructor(syncHandlerId, handlers) { this.syncHandlerId = syncHandlerId; this.handlers = handlers; } update(handlers) { for (const handle in handlers) { this.handlers[handle] = handlers[handle]; } } } function handleSyncEvent({type, id, data}) { let handler = null; switch (type) { case 'upload': handler = syncHandler.handlers.uploadSync; break; case 'download': handler = syncHandler.handlers.downloadSync; break; case 'backup': handler = syncHandler.handlers.backup; break; case 'restore': handler = syncHandler.handlers.restore; break; default: console.log('mailvelope-client-api unknown sync event', type); } if (!handler) { emit('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: type, error: {message: 'Sync handler not available'}, id}); return; } handler(data) .then(result =&gt; { emit('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: type, syncData: result, id}); }) .catch(error =&gt; { if (!error) { error = new Error('Unknown Error'); } if (error instanceof Error || typeof error === 'string') { error = {message: error.message || String(error)}; } emit('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: type, error, id}); }); } function eventListener(msg) { if (msg.origin !== window.location.origin || msg.data.mvelo_client || !msg.data.mvelo_extension) { return; } //console.log('clientAPI eventListener', event.data); switch (msg.data.event) { case 'sync-event': handleSyncEvent(msg.data); break; case '_reply': { let error; if (msg.data.error) { error = mapError(msg.data.error); if (!callbacks[msg.data._reply]) { throw error; } } callbacks[msg.data._reply](error, msg.data.result); delete callbacks[msg.data._reply]; break; } default: console.log('mailvelope-client-api unknown event', msg.data.event); } } function disconnectListener() { window.removeEventListener('message', eventListener); connected = false; } function getHash() { let result = ''; const buf = new Uint16Array(6); window.crypto.getRandomValues(buf); for (let i = 0; i &lt; buf.length; i++) { result += buf[i].toString(16); } return result; } function mapError(obj) { const error = new Error(obj.message); error.code = obj.code; return error; } function checkConnection() { if (!connected) { const error = new Error('Connection to Mailvelope extension is no longer alive.'); error.code = 'NO_CONNECTION'; throw error; } } function emit(event, data) { checkConnection(); const message = {...data, event, mvelo_client: true}; window.postMessage(message, window.location.origin); } function send(event, data) { checkConnection(); return new Promise((resolve, reject) =&gt; { const message = {...data, event, mvelo_client: true, _reply: getHash()}; callbacks[message._reply] = (err, data) =&gt; err ? reject(err) : resolve(data); window.postMessage(message, window.location.origin); }); } export function init() { window.mailvelope = new Mailvelope(); window.addEventListener('message', eventListener); window.addEventListener('mailvelope-disconnect', disconnectListener); window.setTimeout(() =&gt; { window.dispatchEvent(new CustomEvent('mailvelope', {detail: window.mailvelope})); }, 1); } × Search results Close "},"web-components.js.html":{"id":"web-components.js.html","title":"Source: web-components.js","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Source: web-components.js /** * The MIT License (MIT) * * Copyright (c) 2018-2019 Mailvelope GmbH * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ /** * OpenPGPEncryptedForm custom HTMLElement */ class OpenPGPEncryptedForm extends HTMLElement { // Invoked when the custom element is first connected to the document's DOM. connectedCallback() { this.dispatchEvent(new Event('connected')); const id = this.getAttribute('id'); if (!id) { const error = new Error('No form id for openpgp-encrypted-tag. Please add a unique identifier.'); error.code = 'NO_FORM_ID'; return this.onError(error); } let html; const scriptTags = this.getElementsByTagName('script'); if (scriptTags.length) { html = scriptTags[0].innerText; } else { const error = new Error('No form template for openpgp-encrypted-tag. Please add a form template.'); error.code = 'NO_FORM_SCRIPT'; return this.onError(error); } window.mailvelope.createEncryptedFormContainer(`#${id}`, html, this.getAttribute('signature')) .then(data =&gt; this.onEncrypt(data), error =&gt; this.onError(error)); } onEncrypt(data) { this.dispatchEvent(new CustomEvent('encrypt', { detail: {armoredData: data.armoredData}, bubbles: true, cancelable: true })); } onError(error) { this.dispatchEvent(new ErrorEvent('error', { message: error.message, error })); } } export function init() { // See. https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements#Specification#Browser_compatibility if (typeof window.customElements !== 'undefined') { window.customElements.define('openpgp-encrypted-form', OpenPGPEncryptedForm); } } × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Global Type Definitions AsciiArmored Ascii Armored PGP Text Block Type: string Source: client-api.js, line 62 BackupSyncHandler() Parameters: Type Description BackupSyncPacket object with backup data Source: client-api.js, line 391 Returns: Type Promise.&lt;undefined, Error&gt; BackupSyncPacket Type: Object Properties: Name Type Description backup AsciiArmored encrypted key backup as PGP armored message Source: client-api.js, line 386 CssSelector CSS Selector String Type: string Source: client-api.js, line 67 DisplayContainer Type: Object Properties: Name Type Description error Error Error object with code and message attribute error.code = 'DECRYPT_ERROR' - generic decrypt error error.code = 'ARMOR_PARSE_ERROR' - error while parsing the armored message error.code = 'PWD_DIALOG_CANCEL' - user canceled password dialog error.code = 'NO_KEY_FOUND' - no private key found to decrypt this message Source: client-api.js, line 78 DisplayContainerOptions Type: Object Properties: Name Type Description showExternalContent boolean if true loads external content into the display container (default: true) senderAddress string email address of sender, used to indentify key for signature verification Source: client-api.js, line 72 DownloadSyncHandler(downloadObj) Parameters: Name Type Description downloadObj Object meta info for download Properties Name Type Description eTag string entity tag for the current local keyring, or null if no local eTag Source: client-api.js, line 378 Returns: if version on server has same eTag, then keyringMsg property of reply is empty, but eTag in reply has to be set if server is initial and downloadObj.eTag is not null, then the promise is resolved with empty eTag Type Promise.&lt;DownloadSyncReply, Error&gt; DownloadSyncReply Type: Object Properties: Name Type Description keyringMsg AsciiArmored encrypted keyring as PGP armored message, or null if no newer version available eTag String entity tag for the current encrypted keyring message, or null if server is intial Source: client-api.js, line 372 EditorContainerOptions Type: Object Properties: Name Type Description quota number mail content (text + attachments) limit in kilobytes (default: 20480) signMsg boolean if true then the mail will be signed (default: false) armoredDraft AsciiArmored a PGP message, signed and encrypted with the default key of the user, will be used to restore a draft in the editor The armoredDraft parameter can't be combined with the parameters: predefinedText, quotedMail... parameters, keepAttachments predefinedText string text that will be added to the editor quotedMail AsciiArmored mail that should be quoted quotedMailIndent boolean if true the quoted mail will be indented (default: true) quotedMailHeader string header to be added before the quoted mail keepAttachments boolean add attachments of quotedMail to editor (default: false) Source: client-api.js, line 110 KeyBackupContainerOptions Type: Object Source: client-api.js, line 319 KeyGenContainerOptions Type: Object Properties: Name Type Description userIds Array.&lt;UserId&gt; array of user IDs. The first entry in the array is set as the primary user ID. keySize number key size in bit, optional, default: 2048, valid values: 2048, 4096. Source: client-api.js, line 301 PrivateKeyContainerOptions Type: Object Properties: Name Type Description restorePassword boolean (default: false) Source: client-api.js, line 334 RestoreSyncHandler() Source: client-api.js, line 397 Returns: Type Promise.&lt;BackupSyncPacket, Error&gt; SettingsContainerOptions Type: Object Properties: Name Type Description email string the email address of the current user fullName string the full name of the current user Source: client-api.js, line 152 SyncHandlerObject Type: Object Properties: Name Type Description uploadSync UploadSyncHandler function called by Mailvelope to upload the keyring (public keys), the message is encrypted with the default private key downloadSync DownloadSyncHandler function called by Mailvelope to download the encrypted keyring (public keys) backup BackupSyncHandler function called by Mailvelope to upload a symmetrically encrypted private key backup restore RestoreSyncHandler function called by Mailvelope to restore a private key backup Source: client-api.js, line 402 UploadSyncHandler(uploadObj) Parameters: Name Type Description uploadObj Object object with upload data Properties Name Type Description eTag string entity tag for the uploaded encrypted keyring, or null if initial upload keyringMsg AsciiArmored encrypted keyring as PGP armored message Source: client-api.js, line 363 Returns: if version on server has different eTag, then the promise is rejected if server is initial and uploadObj.eTag is not null, then the promise is rejected Type Promise.&lt;UploadSyncReply, Error&gt; UploadSyncReply Type: Object Properties: Name Type Description eTag String entity tag for the uploaded encrypted keyring Source: client-api.js, line 358 UserId Type: Object Properties: Name Type Description email string the email address of the current user fullName string the full name of the current user Source: client-api.js, line 295 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Classes Classes Editor Generator KeyBackupPopup Keyring Mailvelope OpenPGPEncryptedForm RestoreBackup × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Tutorials Classes Editor Generator KeyBackupPopup Keyring Mailvelope OpenPGPEncryptedForm RestoreBackup × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Basic UsageThe Mailvelope extension injects a script into the page to make its client-api accessible.The window.mailvelope object will be an instance of the Mailvelope class, please refer to its methods for further documentation. EventsmailvelopeThe event will be triggered once the window.mailvelope object is available.Since the timing is not defined consumers will have to use the following method or something equivalent to reliably obtain a reference to the Mailvelope client-API. (function() { function init() { if (typeof mailvelope !== 'undefined') { mailvelopeLoaded(); } else { window.addEventListener('mailvelope', mailvelopeLoaded, false); } } function mailvelopeLoaded() { // window.mailvelope object is available } $(document).ready(init); }());mailvelope-disconnectThe event is fired during an update of the extension. The auto-update mechanism of the browser can initiate the update at any time.Existing Mailvelope containers on a consumer page are no longer functional after the update. The disconnect event can be used to inform users about potential data loss (only relevant for Mailvelope editor) and trigger a page reload. window.addEventListener('mailvelope-disconnect', function(event) { // event.detail.version is the version of the updated extension }, false);PromisesThe client-API uses the new ECMAScript 6 Promises. At the moment JSDoc does not have specialized support for this newlanguage feature, although adding support is in discussion. Due to this reasonwe will use the @throws tag to document errors that should be expected in the rejection of a promise and will not actuallybe thrown by the function returning the promise. × Search results Close "},"Editor.html":{"id":"Editor.html","title":"Class: Editor","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: Editor Editor Not accessible, instance can be obtained using Mailvelope#createEditorContainer. new Editor(editorId) Parameters: Name Type Description editorId string the internal id of the editor Source: client-api.js, line 507 Methods createDraft() Encrypt and sign the content of the editor with the default key of the user.To be used to save drafts. To restore drafts use the options.armoredDraft parameter of the createEditorContainer method. Source: client-api.js, line 536 Throws: error.code = 'ENCRYPT_IN_PROGRESS' error.code = 'NO_KEY_FOR_ENCRYPTION' error.code = 'ENCRYPT_QUOTA_SIZE' Type Error Returns: Type Promise.&lt;AsciiArmored, Error&gt; encrypt(recipients) Requests the encryption of the editor content for the given recipients. Parameters: Name Type Description recipients Array.&lt;string&gt; list of email addresses for public key lookup and encryption Source: client-api.js, line 524 Throws: error.code = 'ENCRYPT_IN_PROGRESS' error.code = 'NO_KEY_FOR_RECIPIENT' error.code = 'ENCRYPT_QUOTA_SIZE' Type Error Returns: Type Promise.&lt;AsciiArmored, Error&gt; Example editor.encrypt(['abc@web.de', 'info@com']).then(function (armoredMessage) { console.log('encrypt', armoredMessage); // prints: \"-----BEGIN PGP MESSAGE...\" } × Search results Close "},"Generator.html":{"id":"Generator.html","title":"Class: Generator","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: Generator Generator Not accessible, instance can be obtained using Keyring#createKeyGenContainer. new Generator(generatorId) Parameters: Name Type Description generatorId string the internal id of the generator Source: client-api.js, line 459 Methods generate( [confirm]) Generate a private key Parameters: Name Type Argument Description confirm Promise.&lt;undefined, Error&gt; &lt;optional&gt; newly generate key is only persisted if Promise resolves, in the reject or timeout case the generated key is rejected Source: client-api.js, line 471 Throws: Error Returns: the newly generated key (public part) Type Promise.&lt;AsciiArmored, Error&gt; × Search results Close "},"KeyBackupPopup.html":{"id":"KeyBackupPopup.html","title":"Class: KeyBackupPopup","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: KeyBackupPopup KeyBackupPopup Not accessible, instance can be obtained using Keyring#createKeyBackupContainer new KeyBackupPopup(popupId) Parameters: Name Type Description popupId string Source: client-api.js, line 441 Methods isReady() Source: client-api.js, line 450 Throws: Error Returns: key backup ready or error Type Promise.&lt;undefined, Error&gt; × Search results Close "},"Keyring.html":{"id":"Keyring.html","title":"Class: Keyring","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: Keyring Keyring Not accessible, instance can be obtained using Mailvelope#getKeyringor Mailvelope#createKeyring. new Keyring(identifier, options) Parameters: Name Type Description identifier string the keyring identifier options object the options Properties: Name Type Description logoRev number revision number of the keyring logo, initial value: 0 Source: client-api.js, line 209 Methods addSyncHandler(syncHandlerObj) Add various functions for keyring synchronization Parameters: Name Type Description syncHandlerObj SyncHandlerObject Source: client-api.js, line 415 Returns: Type Promise.&lt;undefined, Error&gt; createKeyBackupContainer(selector, options) Creates an iframe to initiate the key backup process. Parameters: Name Type Description selector CssSelector target container options KeyBackupContainerOptions Source: client-api.js, line 330 Returns: Type Promise.&lt;KeyBackupPopup, Error&gt; createKeyGenContainer(selector, options) Creates an iframe to display the key generation container.The iframe will be injected into the container identified by selector. Parameters: Name Type Description selector CssSelector target container options KeyGenContainerOptions Source: client-api.js, line 315 Throws: error.code = 'INPUT_NOT_VALID' Type Error Returns: Type Promise.&lt;Generator, Error&gt; exportOwnPublicKey(emailAddr) Exports the public key as an ascii armored string.Only keys belonging to the user (corresponding private key exists) can be exported. Parameters: Name Type Description emailAddr string email address to identify the public+private key Source: client-api.js, line 255 Throws: error.code = 'NO_KEY_FOR_ADDRESS' Type Error Returns: Type Promise.&lt;AsciiArmored, Error&gt; Example keyring.exportOwnPublicKey('abc@web.de').then(function(armoredPublicKey) { console.log('exportOwnPublicKey', armoredPublicKey); // prints: \"-----BEGIN PGP PUBLIC KEY BLOCK...\" }); hasPrivateKey(fingerprint) Check if keyring contains valid private key with given fingerprint Parameters: Name Type Description fingerprint string Source: client-api.js, line 354 Returns: Type Promise.&lt;boolean, Error&gt; importPublicKey(armored) Asks the user if they want to import the public key. Parameters: Name Type Description armored AsciiArmored public key to import Source: client-api.js, line 269 Throws: error.code = 'IMPORT_ERROR' error.code = 'WRONG_ARMORED_TYPE' Type Error Returns: 'IMPORTED' - key has been imported 'UPDATED' - key already in keyring, new key merged with existing key 'INVALIDATED' - key has been updated, new status of key is 'invalid' (e.g. revoked) 'REJECTED' - key import rejected by user Type Promise.&lt;String, Error&gt; openSettings() Open the extension settings in a new browser tab Source: client-api.js, line 432 Returns: Type Promise.&lt;undefined, Error&gt; restoreBackupContainer(selector, options) Creates an iframe to restore the backup. Parameters: Name Type Description selector CssSelector target container options PrivateKeyContainerOptions Source: client-api.js, line 345 Returns: Type Promise.&lt;undefined, Error&gt; setLogo(dataURL, revision) Set logo for keyring. The image is persisted in Mailvelope with a revision number,therefore the method is only required after new keyring generation or if logo and revision number changes. Parameters: Name Type Description dataURL string data-URL representing the logo, max. file size: ~10KB, max. image size: 192x96px, content-type: image/png revision number revision number Source: client-api.js, line 289 Throws: error.code = 'LOGO_INVALID' error.code = 'REVISION_INVALID' Type Error Returns: Type Promise.&lt;undefined, Error&gt; Example keyring.setLogo('data:image/png;base64,iVBORS==', 3).then(function() { // keyring.logoRev == 3 }).catch(function(error) { // logo update failed }); validKeyForAddress(recipients) Checks for valid key in the keyring for provided email addresses Parameters: Name Type Description recipients Array list of email addresses for key lookup Source: client-api.js, line 231 Returns: an object that maps email addresses to a status or key info object (false: no valid key, {}: valid key) Type Promise.&lt;Object, Error&gt; Example keyring.validKeyForAddress(['abc@web.de', 'info@mailvelope.com']).then(function(result) { console.log(result); // { // 'abc@web.de': false, // 'info@mailvelope.com': { // keys: [ // {fingerprint: 'f37377c39898d05ffd39157a98bbec557ce08def', lastModified: Tue May 19 2015 10:36:53 GMT+0200 (CEST)} // ] // } }); × Search results Close "},"Mailvelope.html":{"id":"Mailvelope.html","title":"Class: Mailvelope","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: Mailvelope Mailvelope new Mailvelope() Source: client-api.js, line 28 Methods createDisplayContainer(selector, armored, keyring, options) Creates an iframe to display the decrypted content of the encrypted mail.The iframe will be injected into the container identified by selector. Parameters: Name Type Description selector CssSelector target container armored AsciiArmored the encrypted mail to display keyring Keyring the keyring to use for this operation options DisplayContainerOptions Source: client-api.js, line 96 Returns: Type Promise.&lt;DisplayContainer, Error&gt; createEditorContainer(selector, keyring, options) Creates an iframe with an editor for a new encrypted mail.The iframe will be injected into the container identified by selector. Parameters: Name Type Description selector CssSelector target container keyring Keyring the keyring to use for this operation options EditorContainerOptions Source: client-api.js, line 143 Throws: error.code = 'WRONG_ARMORED_TYPE' - parameters of type AsciiArmored do not have the correct armor type error.code = 'INVALID_OPTIONS' - invalid combination of options parameter Type Error Returns: Type Promise.&lt;Editor, Error&gt; Example mailvelope.createEditorContainer('#editor-element', keyring).then(function(editor) { // register event handler for mail client send button $('#mailer-send').click(function() { // encrypt current content of editor for array of recipients editor.encrypt(['info@mailvelope.com', 'abc@web.de']).then(function(armored) { console.log('encrypted message', armored); }); }); }); createEncryptedFormContainer(@param, @param, @param) Creates an iframe to display an encrypted formThe iframe will be injected into the container identified by selector. Parameters: Name Type Description @param string selector - the id of target container @param string formHtml - the form definition @param string signature - the OpenPGP signature Source: client-api.js, line 184 Throws: error.code = 'INVALID_FORM' the form definition is not valid Type Error Returns: an object that includes armoredData Type Promise.&lt;Object, Error&gt; createKeyring(identifier) Creates a Keyring for the given identifier Parameters: Name Type Description identifier string the identifier of the new keyring Source: client-api.js, line 58 Throws: error.code = 'KEYRING_ALREADY_EXISTS' Type Error Returns: Type Promise.&lt;Keyring, Error&gt; Example mailvelope.createKeyring('Account-ID-4711').then(function(keyring) { // continue to display the settings container and start the setup wizard mailvelope.createSettingsContainer('#mailvelope-settings', keyring); }); createSettingsContainer(selector, keyring, options) Creates an iframe to display the keyring settings.The iframe will be injected into the container identified by selector. Parameters: Name Type Description selector CssSelector target container keyring Keyring the keyring to use for the setup options SettingsContainerOptions Source: client-api.js, line 166 Returns: Type Promise.&lt;undefined, Error&gt; getKeyring(identifier) Retrieves the Keyring for the given identifier Parameters: Name Type Description identifier string the identifier of the keyring Source: client-api.js, line 43 Throws: error.code = 'NO_KEYRING_FOR_ID' Type Error Returns: Type Promise.&lt;Keyring, Error&gt; getVersion() Gives access to the mailvelope extension version Source: client-api.js, line 33 Returns: Type Promise.&lt;String, Error&gt; × Search results Close "},"OpenPGPEncryptedForm.html":{"id":"OpenPGPEncryptedForm.html","title":"Class: OpenPGPEncryptedForm","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: OpenPGPEncryptedForm OpenPGPEncryptedForm OpenPGPEncryptedForm custom HTMLElement new OpenPGPEncryptedForm() Source: web-components.js, line 28 × Search results Close "},"RestoreBackup.html":{"id":"RestoreBackup.html","title":"Class: RestoreBackup","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: RestoreBackup RestoreBackup Not accessible, instance can be obtained using Keyring#restoreBackupContainer. new RestoreBackup(restoreId) Parameters: Name Type Description restoreId string the internal id of the restore backup Source: client-api.js, line 489 Methods isReady() Source: client-api.js, line 498 Throws: Error Returns: key restore ready or error Type Promise.&lt;undefined, Error&gt; × Search results Close "},"tutorial-Readme.html":{"id":"tutorial-Readme.html","title":"Tutorial: Readme","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Readme Basic UsageThe Mailvelope extension injects a script into the page to make its client-api accessible.The window.mailvelope object will be an instance of the Mailvelope class, please refer to its methods for further documentation. EventsmailvelopeThe event will be triggered once the window.mailvelope object is available.Since the timing is not defined consumers will have to use the following method or something equivalent to reliably obtain a reference to the Mailvelope client-API. (function() { function init() { if (typeof mailvelope !== 'undefined') { mailvelopeLoaded(); } else { window.addEventListener('mailvelope', mailvelopeLoaded, false); } } function mailvelopeLoaded() { // window.mailvelope object is available } $(document).ready(init); }());mailvelope-disconnectThe event is fired during an update of the extension. The auto-update mechanism of the browser can initiate the update at any time.Existing Mailvelope containers on a consumer page are no longer functional after the update. The disconnect event can be used to inform users about potential data loss (only relevant for Mailvelope editor) and trigger a page reload. window.addEventListener('mailvelope-disconnect', function(event) { // event.detail.version is the version of the updated extension }, false);PromisesThe client-API uses the new ECMAScript 6 Promises. At the moment JSDoc does not have specialized support for this newlanguage feature, although adding support is in discussion. Due to this reasonwe will use the @throws tag to document errors that should be expected in the rejection of a promise and will not actuallybe thrown by the function returning the promise. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
